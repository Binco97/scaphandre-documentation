<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Scaphandre documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Extensible and lightweight monitoring agent for energy consumption metrics">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-f775c0bf.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-a43539e4.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Scaphandre documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/hubblo-org/scaphandre/"><img src="scaphandre.svg" width="250px" /></a></p>
<p>Welcome on <a href="https://github.com/hubblo-org/scaphandre">Scaphandre</a> documentation.</p>
<p>Scaphandre is a <strong>monitoring agent</strong>, dedicated to <strong>energy consumption</strong> metrics. Its purpose is to help measuring and thus understanding tech services energy consumption patterns. This is key, in our opinion, to enable the tech industry to shift towards more sustainability. üíö</p>
<p>If at this point you think ‚Äúwhy bother ?‚Äù, or if you want more details about this project‚Äôs motivations, please have a look at the <a href="#why-">why</a> section.</p>
<p>If not and you want to proceed, just directly jump to the <a href="#getting-started">tutorials</a> section.</p>
<p>If you need more in-depth, use-case oriented instructions, the <a href="#propagate-power-consumption-metrics-from-hypervisor-to-virtual-machines-qemukvm">how-to guides</a> are here for you.</p>
<p><a href="#how-scaphandre-computes-per-process-power-consumption">Explanations</a> is about theoretical concepts behind scaphandre and the reasons for the technical choices that have been made so far.</p>
<p>If you are already using, hacking or exploring scaphandre and need precise informations about one of its components, go to the <a href="#prometheus-exporter">references</a> section. (The code documentation itself is <a href="https://docs.rs/scaphandre/">here</a>).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>To install Scaphandre, depending on your platform, see:</p>
<ul>
<li><a href="#installation-gnulinux">Installation on GNU/Linux</a> section.</li>
<li><a href="#install-scaphandre-on-windows">Installation on Windows</a> section.</li>
</ul>
<p>If you want to contribute or just play with the code and need to compile Scaphandre, see :</p>
<ul>
<li><a href="#compile-scaphandre-from-source-gnulinux">Compilation on GNU/Linux</a>.</li>
<li><a href="#compilation-for-windows-experimental">Compilation on Windows</a>.</li>
</ul>
<p>Depending on your kernel version, you could need to modprobe the module intel_rapl or intel_rapl_common first:</p>
<pre><code>modprobe intel_rapl_common # or intel_rapl for kernels &lt; 5
</code></pre>
<p>To quickly run scaphandre in your terminal you may use <a href="https://www.docker.com/">docker</a>:</p>
<pre><code>docker run --privileged -v /sys/class/powercap:/sys/class/powercap -v /proc:/proc -ti hubblo/scaphandre stdout -t 15
</code></pre>
<p>To run scaphandre you need to run the contaner in <strong>privileged</strong> mode since it is needed to access <code>/proc</code> files.</p>
<p>Or if you downloaded or built a binary, you‚Äôd run:</p>
<pre><code>scaphandre stdout -t 15
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>Here we are using the stdout <a href="#internal-structure">exporter</a> to print current power consumption usage in the terminal during 15 seconds.</p>
<p>You should get an output like:</p>
<pre><code>Host:	9.391334 W	Core		Uncore		DRAM
Socket0	9.392    W	1.497082 W
Top 5 consumers:
Power	PID	Exe
4.808363 W	642	"/usr/sbin/dockerd"
4.808363 W	703	"/usr/bin/docker-containerd"
4.808363 W	1028	"/usr/local/bin/redis-server"
0 W	1	"/usr/lib/systemd/systemd"
0 W	2	""
------------------------------------------------------------
</code></pre>
<p>Let‚Äôs briefly describe what you see here. First Line is the power consumption of the machine (between the two last measurements).
Second line is the power consumption of the first CPU socket plus the detail by RAPL Domain.
If you have more than one CPU Socket, you‚Äôll have multiple <em>SocketX</em> lines.
Then you have the 5 processes consuming the most power during the last two measurements.</p>
<p>If you don‚Äôt get this output and get an error, jump to the <a href="#troubleshooting-3">Troubleshooting</a> section of the documentation.</p>
<h2 id="going-further"><a class="header" href="#going-further">Going further</a></h2>
<p>At that point, you‚Äôre ready to use scaphandre. The Stdout exporter is very basic and other exporters should allow you to use and send those metrics the way you like.</p>
<p>The <a href="#prometheus-exporter">prometheus exporter</a>, for example, allows you to expose power consumption metrics as an HTTP endpoint that can be scrapped by a <a href="https://prometheus.io">prometheus</a> instance:</p>
<pre><code>docker run --privileged -v /sys/class/powercap:/sys/class/powercap -v /proc:/proc -p 8080:8080 -ti hubblo/scaphandre prometheus
</code></pre>
<p>Here is the same command with a simple binary:</p>
<pre><code>scaphandre prometheus
</code></pre>
<p>To validate that the metrics are available, send an http request from another terminal:</p>
<pre><code>curl -s http://localhost:8080/metrics
</code></pre>
<p><a href="https://metrics.hubblo.org">Here</a> you can see examples of graphs you can get thanks to scaphandre, the prometheus exporter, prometheus and <a href="https://grafana.com/">grafana</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation-gnulinux"><a class="header" href="#installation-gnulinux">Installation (GNU/Linux)</a></h1>
<p>Depending on your kernel version, you could need to modprobe the module intel_rapl or intel_rapl_common before running scaphandre:</p>
<pre><code>modprobe intel_rapl_common # or intel_rapl for kernels &lt; 5
</code></pre>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>To quickly run scaphandre in your terminal you may use <a href="https://www.docker.com/">docker</a>:</p>
<pre><code>docker run -v /sys/class/powercap:/sys/class/powercap -v /proc:/proc -ti hubblo/scaphandre stdout -t 15
</code></pre>
<h2 id="debianubuntu"><a class="header" href="#debianubuntu">Debian/Ubuntu</a></h2>
<p>Since Debian Sid, Scaphandre is available as an official package, try:</p>
<pre><code>sudo apt install scaphandre
</code></pre>
<p>If not (yet) in your official packages repositories, on Debian or Ubuntu, you can directly use the available <code>.deb</code> <a href="https://github.com/hubblo-org/scaphandre/releases/download/v1.0.0/scaphandre_v1.0.0-deb11_amd64.deb">package for Debian Bullseye</a> or the <a href="https://github.com/hubblo-org/scaphandre/releases/download/v1.0.0/scaphandre_v1.0.0-deb12_amd64.deb">package for Debian Bookworm</a>.</p>
<pre><code>#¬†For Debian Bookworm
VERSION="1.0.1" ARCH="amd64" DIST="deb12" &amp;&amp; \
wget https://github.com/hubblo-org/scaphandre/releases/download/v${VERSION}/scaphandre_v${VERSION}-${DIST}_${ARCH}.deb &amp;&amp; \
dpkg -i scaphandre_v${VERSION}\-${DIST}\_${ARCH}.deb &amp;&amp; \
rm scaphandre_v${VERSION}\-${DIST}\_${ARCH}.deb
</code></pre>
<h2 id="run-the-binary"><a class="header" href="#run-the-binary">Run the binary</a></h2>
<p>Once you downloaded or built a binary, you‚Äôd run:</p>
<pre><code>scaphandre stdout -t 15
</code></pre>
<p>Here are some other ways to install scaphandre depending on your context:</p>
<ul>
<li><a href="#run-a-complete-stack-with-docker-compose">quickly try the project with docker-compose/docker stack</a></li>
<li><a href="#kubernetes">run scaphandre on kubernetes</a></li>
<li><a href="#install-scaphandre-with-only-prometheus-push-exporter-compiled-for-prometheus-push-gateway-on-rhel-8-and-9">run scaphandre on RHEL, with prometheus-push mode</a></li>
</ul>
<p>Kudos to contributors who work on system packages, please have a try and/or contribute to:</p>
<ul>
<li><a href="https://github.com/barnumbirr/scaphandre-debian">Debian package</a>, maintainer: @barnumbirr</li>
<li><a href="https://github.com/mmai/scaphandre-flake">NixOS package</a>, maintainer: @mmai</li>
</ul>
<p>Other tutorials should come, as:</p>
<ul>
<li>install scaphandre as a proper systemd service</li>
<li>scaphandre in your favorite GNU/Linux distribution (need help from packaging gurus !)</li>
<li>scaphandre on MacOSX</li>
<li>and more‚Ä¶</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="install-scaphandre-on-windows"><a class="header" href="#install-scaphandre-on-windows">Install Scaphandre on Windows</a></h1>
<p><strong>!! Warning: Windows version of Scaphandre is still in early stage. !!</strong></p>
<h2 id="using-the-installer"><a class="header" href="#using-the-installer">Using the installer</a></h2>
<p>Download the latest exe installer <a href="https://github.com/hubblo-org/scaphandre/releases">from the release page</a> and install it <strong>as an administrator</strong>.</p>
<h3 id="configuring-a-windows-service-to-run-scaphandre-in-the-background"><a class="header" href="#configuring-a-windows-service-to-run-scaphandre-in-the-background">Configuring a Windows service to run Scaphandre in the background</a></h3>
<p>For example, to run the prometheus-push exporter in the background and target the Prometheus Push Gateway server with ip address <code>198.51.100.5</code> using HTTPS on port 443 and a step to send metrics of 45s, without checking the certificate of the push gateway (remove that option if you have a properly signed TLS certificate):</p>
<pre><code>sc.exe create Scaphandre binPath="C:\Program Files (x86)\scaphandre\scaphandre.exe prometheus-push -H 198.51.100.5 -s 45 -S https -p 443 --no-tls-check" DisplayName=Scaphandre start=auto
</code></pre>
<p>Ensure the service is started in Services.msc, start it by right clicking on it, then Start, otherwise.</p>
<p>To delete the service, you can do it in Services.msc, or:</p>
<pre><code>sc.exe delete Scaphandre
</code></pre>
<h3 id="using-an-installer-including-a-development-version-of-the-driver"><a class="header" href="#using-an-installer-including-a-development-version-of-the-driver">Using an installer including a development version of the driver</a></h3>
<p>If you are running a development version of the installer (which probably means a development version of the <a href="https://github.com/hubblo-org/windows-rapl-driver/">driver</a>), you‚Äôll need to enable Test Mode on Windows prior to proceed to this installation, then reboot.</p>
<pre><code>bcdedit.exe -set TESTSIGNING ON
bcdedit.exe -set nointegritychecks on
</code></pre>
<p>Beware: in this case, activation of test mode <strong>and a reboot</strong> is needed before anyway.</p>
<p>Once installed, you should be able to run scaphandre from Powershell, by running :</p>
<pre><code>&amp; 'C:\Program Files (x86)\scaphandre\scaphandre.exe' stdout
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>An error such as</p>
<pre><code>scaphandre::sensors::msr_rapl: Failed to open device : HANDLE(-1)
</code></pre>
<p>means that the driver is not properly setup. Check it‚Äôs state by running:</p>
<pre><code>driverquery /v | findstr capha
</code></pre>
<p>If there is not item returned, the installation of the driver encountered an issue.</p>
<p>If the service is STOPPED, there is also something wrong.</p>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>If you look for compiling Scaphandre and its driver yourself, see <a href="#compilation-for-windows-experimental">Compilation for Windows</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="run-a-complete-stack-with-docker-compose"><a class="header" href="#run-a-complete-stack-with-docker-compose">Run a complete stack with docker-compose</a></h1>
<p>If you‚Äôd like to try scaphandre and see the data in a decent visualization tool, there is a docker-compose in the repository to install scaphandre along side with <a href="https://prometheus.io">prometheus</a> and <a href="https://grafana.com">grafana</a>.</p>
<p>Once you have cloned the repository, just move to the docker-compose folder and run the stack:</p>
<pre><code>cd docker-compose
docker-compose up -d
</code></pre>
<p>Be warned: the sample stack runs scaphandre as a privileged container. Otherwise apparmor or equivalents might complain about ptrace calls on the host. See <a href="https://github.com/hubblo-org/scaphandre/issues/135">#135</a>.</p>
<p>Grafana will be available at <code>http://localhost:3000</code>, the default username is <code>admin</code> and the password is <code>secret</code>.</p>
<p>Refresh the dashboard after 30s or enable auto-refresh and you should see the data filling the graphs.</p>
<p>The <code>process_filter</code> textbox on the top of the graph allows you to look at the power consumption of a single application or service. Type the name of the program you want to look at and press enter. In the <code>Filtered process (process_filter) power, by exe</code> graph, on the 3rd line, you should now see the power cosumption of the given program.</p>
<p>To remove the stack just run this command in the same folder:</p>
<pre><code>docker-compose down
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="compile-scaphandre-from-source-gnulinux"><a class="header" href="#compile-scaphandre-from-source-gnulinux">Compile scaphandre from source (GNU/Linux)</a></h1>
<p>We recommand using this version of the rust toolchain or later:</p>
<pre><code>cargo --version
cargo 1.48.0 (65cbdd2dc 2020-10-14)
rustc --version
rustc 1.48.0 (7eac88abb 2020-11-16)
</code></pre>
<p>To be sure to be up to date, you may install rust from the <a href="https://www.rust-lang.org/">official website</a> instead of your package manager.</p>
<p>To hack <em>scaph</em>, or simply be up to date with latest developments, you can download scaphandre from the main branch:</p>
<pre><code>git clone https://github.com/hubblo-org/scaphandre.git
cd scaphandre
cargo build # binary path is target/debug/scaphandre
</code></pre>
<p>To use the latest code for a true use case, build for release instead of debug:</p>
<pre><code>cargo build --release
</code></pre>
<p>Binary path is <code>target/release/scaphandre</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="compilation-for-windows-experimental"><a class="header" href="#compilation-for-windows-experimental">Compilation for Windows (experimental)</a></h1>
<p>Scaphandre, on Windows, needs a kernel driver to get the same metrics as it does with powercap on GNU/Linux. This driver is available on <a href="https://github.com/hubblo-org/windows-rapl-driver/">this repository</a>. Please refer to this project to get either pre-compiled binaries (available soon) or to follow the compilation procedure.</p>
<p><img src="https://repository-images.githubusercontent.com/421079628/f695abc0-c8e6-46a3-a6f4-6c7c0f617b87" alt="Scaphandre‚Äôs dependencies on Windows and GNU/Linux"></p>
<p>Once you have a working driver, you can compile Scaphandre, with the Rust for Windows usual toolkit.</p>
<p>For now, all Scaphandre features are not supported on windows. Use the following command line to build the binary :</p>
<pre><code>cargo build --no-default-features --features "prometheus json riemann"
</code></pre>
<p>Don‚Äôt forget to add the <code>--release</code> flag to build a binary suited for more than test and debug usecases.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p>This tutorial uses <a href="https://helm.sh/docs/intro/quickstart/">Helm</a> to install
Scaphandre, Prometheus and Grafana.</p>
<h2 id="install-scaphandre"><a class="header" href="#install-scaphandre">Install Scaphandre</a></h2>
<p>First we install Scaphandre which runs as a daemon set which creates a pod on
each node for collecting the metrics. The helm chart is not in a repo, it needs
to be installed from the source code.</p>
<pre><code>git clone https://github.com/hubblo-org/scaphandre
cd scaphandre
helm install scaphandre helm/scaphandre
</code></pre>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<h4 id="service-monitor-parameters"><a class="header" href="#service-monitor-parameters">Service monitor parameters</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Description</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td><code>serviceMonitor.enabled</code></td><td>Create ServiceMonitor Resource for scraping metrics using PrometheusOperator</td><td><code>false</code></td></tr>
<tr><td><code>serviceMonitor.namespace</code></td><td>The namespace in which the ServiceMonitor will be created   (if not set, default to namespace on which this chart is installed)</td><td><code>""</code></td></tr>
<tr><td><code>serviceMonitor.interval</code></td><td>The interval at which metrics should be scraped</td><td><code>1m</code></td></tr>
</tbody>
</table>
</div>
<h4 id="security-parameters"><a class="header" href="#security-parameters">Security Parameters</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Description</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td><code>securityContext.privileged</code></td><td>Gives full host access, bypassing container isolation (can be needed to run on physical server)</td><td><code>false</code></td></tr>
<tr><td><code>securityContext.runAsUser</code></td><td>Run as root user to get proper permissions</td><td><code>0</code></td></tr>
<tr><td><code>securityContext.runAsGroup</code></td><td>Run as root group to get proper permissions</td><td><code>0</code></td></tr>
</tbody>
</table>
</div>
<h2 id="install-prometheus"><a class="header" href="#install-prometheus">Install Prometheus</a></h2>
<p>Next we will install Prometheus which will scrape the metrics generated by Scaphandre.</p>
<pre><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo add kube-state-metrics https://kubernetes.github.io/kube-state-metrics
helm repo update

helm install prometheus prometheus-community/prometheus \
--set alertmanager.persistentVolume.enabled=false \
--set server.persistentVolume.enabled=false
</code></pre>
<p>This setup should only be used for testing as the Prometheus data is not
persisted if the pods are deleted.</p>
<p>You can access the Prometheus web UI by creating a port forwarding connection.</p>
<pre><code>kubectl port-forward deploy/prometheus-server 9090:9090
</code></pre>
<h2 id="install-grafana"><a class="header" href="#install-grafana">Install Grafana</a></h2>
<p>Create a configmap to store the Grafana dashboard.</p>
<pre><code>kubectl create configmap scaphandre-dashboard \
    --from-file=scaphandre-dashboard.json=docs_src/tutorials/grafana-kubernetes-dashboard.json
</code></pre>
<p>Install Grafana.</p>
<pre><code>helm repo add grafana https://grafana.github.io/helm-charts
helm repo update

helm install grafana grafana/grafana --values docs_src/tutorials/grafana-helm-values.yaml
</code></pre>
<p>Get the Grafana web UI password which is randomly generated.</p>
<pre><code>kubectl get secret grafana -o jsonpath="{.data.admin-password}" | base64 --decode
</code></pre>
<p>Create a port forwarding connection to the Grafana pod.</p>
<pre><code>kubectl port-forward deploy/grafana 3000:3000
</code></pre>
<p>Open Grafana in your browser at http://localhost:3000 the username is admin.</p>
<h2 id="cleaning-up"><a class="header" href="#cleaning-up">Cleaning up</a></h2>
<p>Deleting the Helm releases will remove all the resources we created.</p>
<pre><code>helm delete grafana prometheus scaphandre
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="propagate-power-consumption-metrics-from-hypervisor-to-virtual-machines-qemukvm"><a class="header" href="#propagate-power-consumption-metrics-from-hypervisor-to-virtual-machines-qemukvm">Propagate power consumption metrics from hypervisor to virtual machines (Qemu/KVM)</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>A major pain point in measuring power consumption is doing so inside a virtual machine. A virtual machine usually doesn‚Äôt have access to power metrics.</p>
<p>Scaphandre aims at solving that by enabling a communication between a scaphandre instance <strong>on the hypervisor/bare metal machine</strong> and <strong>another one</strong> running <strong>on the virtual machine</strong>.
The scaphandre agent on the hypervisor will <strong>compute the metrics meaningful for that virtual machine</strong> and the one <strong>on the VM access those metrics</strong> to allow its user/administrator to use the data as if they had access to power metrics in the first place (as if they were on a bare metal machine).</p>
<p>This allows to break opacity in a virtualization context, if you have access to the hypervisor, or in a  public cloud context if the provider uses scaphandre on its hypervisors.</p>
<img src="virtu.cleaned.png" width="650" />
<h2 id="how-to"><a class="header" href="#how-to">How to</a></h2>
<p>This is working on Qemu/KVM hypervisors only.</p>
<p>The idea is to run the agent on the hypervisor, with the <a href="#qemu-exporter">qemu exporter</a>:</p>
<pre><code>scaphandre qemu
</code></pre>
<p>More examples for a production ready setup will be added soon (systemd service, docker container, ‚Ä¶). If you think the documentation needs a refresh now, please <a href="https://github.com/hubblo-org/scaphandre/pulls">contribute</a> :)</p>
<p>For each virtual machine you want to give access to its metrics, create a <a href="https://en.wikipedia.org/wiki/Tmpfs">tmpfs</a> mountpoint:</p>
<pre><code> mount -t tmpfs tmpfs_DOMAIN_NAME /var/lib/libvirt/scaphandre/DOMAIN_NAME -o size=5m
</code></pre>
<p>In the definition of the virtual machine (here we are using libvirt), ensure you have a filesystem configuration to give access to the mountpoint:</p>
<pre><code>virsh edit DOMAIN_NAME
</code></pre>
<p>Then add this filesystem configuration block inside the <code>&lt;devices&gt;&lt;/devices&gt;</code> block:</p>
<pre><code>&lt;filesystem type='mount' accessmode='passthrough'&gt;
    &lt;driver type='virtiofs'/&gt;
    &lt;source dir='/var/lib/libvirt/scaphandre/DOMAIN_NAME'/&gt;
    &lt;target dir='scaphandre'/&gt;
    &lt;readonly /&gt;
&lt;/filesystem&gt;
</code></pre>
<p>Save and (re)start the virtual machine.</p>
<p>If you get this error: ‚Äúerror: unsupported configuration: ‚Äòvirtiofs‚Äô requires shared memory‚Äù, you might add this configuration section to the <code>&lt;domain&gt;</code> section.</p>
<pre><code>&lt;memoryBacking&gt;
  &lt;source type='memfd'/&gt;
  &lt;access mode='shared'/&gt;
&lt;/memoryBacking&gt;
</code></pre>
<p>Then connect to the virtual machine and mount the filesystem:</p>
<pre><code> mount -t 9p -o trans=virtio scaphandre /var/scaphandre
</code></pre>
<p>You can now run scaphandre to export the metrics with the exporter of your choice (here prometheus):</p>
<pre><code> scaphandre --vm prometheus
</code></pre>
<p>Please refer to the <a href="#qemu-exporter">qemu exporter</a> reference for more details.</p>
<p><strong>Note:</strong> This how to is only suitable for a ‚Äúmanual‚Äù use case. For all automated systems like openstack or proxmox, some more work needs to be done to make the integration of those steps easier.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="get-process-level-power-consumption-in-my-grafana-dashboard"><a class="header" href="#get-process-level-power-consumption-in-my-grafana-dashboard">Get process-level power consumption in my grafana dashboard</a></h1>
<p>Now we‚Äôll see how to get valuable data in a dashboard. Let‚Äôs say you want to track the power consumption of a given process or application in a dashboard and eventually set thresholds on it. WHat do you need to get that subset of the power consumption of the host visually ?</p>
<p>You need basically 3 components for that:</p>
<ul>
<li>scaphandre running with the <a href="#prometheus-exporter">prometheus exporter</a></li>
<li><a href="https://prometheus.io">prometheus</a></li>
<li><a href="https://grafana.com">grafana</a></li>
</ul>
<p>We‚Äôll say that you already have a running prometheus server and an available grafana instance and that you have added prometheus as a datasource in grafana.</p>
<p>How to get metrics per process as you may see <a href="https://metrics.hubblo.org">here</a> ?</p>
<p>The metric that I need from the prometheus exporter to do that is: <code>scaph_process_power_consumption_microwatts</code>. This metric is a wallet for the power consumption of all the running processes on the host at a given time.</p>
<p>This is a prometheus metrics, so you have labels to filter on the processes you are interested in. Currently the available labels are: <code>instance</code>, <code>exe</code>, <code>job</code> and <code>pid</code>.</p>
<p>If I want to get power consumption (in Watts) for all processes related to <a href="https://nginx.org/">nginx</a> running on a host with ip 10.0.0.9 I may use that query, in grafana, based on the prometheus datasource:</p>
<pre><code>scaph_process_power_consumption_microwatts{cmdline=~".*nginx.*", instance="10.0.0.9:8080"} / 1000000
</code></pre>
<p>Here we assume that scaphandre/the prometheus exporter is running on port number <code>8080</code>.</p>
<p>Here is how it looks, creating a panel in grafana:</p>
<p><img src="grafana-edit.png" alt=""></p>
<p>Those labels are explained in much more detail <a href="#scaph_process_power_consumption_microwatts">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="install-scaphandre-with-only-prometheus-push-exporter-compiled-for-prometheus-push-gateway-on-rhel-8-and-9"><a class="header" href="#install-scaphandre-with-only-prometheus-push-exporter-compiled-for-prometheus-push-gateway-on-rhel-8-and-9">Install Scaphandre with only Prometheus-push exporter compiled, for Prometheus Push Gateway, on RHEL 8 and 9</a></h1>
<h2 id="manual-installation"><a class="header" href="#manual-installation">Manual installation</a></h2>
<p>Scaphandre can be compiled with a limited set of features. You have the choice to only install Scaphandre with prometheus-push exporter (alongside with stdout and json exporters, which might be useful locally).</p>
<p>RPM packages containing only those features are provided for RHEL 8 and 9 :</p>
<ul>
<li><a href="https://scaphandre.s3.fr-par.scw.cloud/x86_64/scaphandre-prometheuspush-dev0.5.18-1.el8.x86_64.rpm">RPM package for RHEL8</a></li>
<li><a href="https://scaphandre.s3.fr-par.scw.cloud/x86_64/scaphandre-prometheuspush-dev0.5.18-1.el9.x86_64.rpm">RPM package for RHEL9</a></li>
</ul>
<p>You can download it and install it just providing the right URL to dnf :</p>
<pre><code>dnf install -y URL
</code></pre>
<p>Then you‚Äôll probably need to change its configuration to target the appropriate Push Gateway server. Edit the configuration file :</p>
<pre><code>vi /etc/scaphandre/prometheuspush
</code></pre>
<p>Default options look like :</p>
<pre><code>SCAPHANDRE_ARGS="prometheus-push -H localhost -S http"
</code></pre>
<p>Those are prometheus-push exporter CLI options. Run the executable to get the reference of the options :</p>
<pre><code>/usr/bin/scaphandre-prometheuspush --help
</code></pre>
<p>A simple configuration to target Push Gateway reachable on https://myserver.mydomain:PORT and send data every 30 seconds would look like :</p>
<pre><code>SCAPHANDRE_ARGS="prometheus-push -H myserver.mydomain -S https -p PORT -s 30"
</code></pre>
<p>Once the configuration is changed, you can restart the service and ensure it is enabled as well for next reboot :</p>
<pre><code>systemctl restart scaphandre-prometheuspush &amp;&amp; systemctl enable scaphandre-prometheuspush
</code></pre>
<p>Configuration issues or issues to reach the push gateway should be visible in the logs :</p>
<pre><code>systemctl status scaphandre-prometheuspush
</code></pre>
<h2 id="automatic-installation-with-ansible"><a class="header" href="#automatic-installation-with-ansible">Automatic installation with ansible</a></h2>
<p>There is a <a href="https://github.com/hubblo-org/scaphandre/blob/dev/automation/ansible/install-configure-prometheuspush-rhel.yml">sample Ansible playbook</a> available in the <a href="https://github.com/hubblo-org/scaphandre/tree/dev/automation/ansible">automation/ansible</a> folder of the project.</p>
<p>This can be used this way :</p>
<pre><code>ansible-playbook -i inventory -b -u myunprivilegeduser -K install-configure-prometheuspush-rhel.yml
</code></pre>
<p>Beware of the playbook parameters :</p>
<pre><code>rhel_version: 9
scaphandre_version: "dev0.5.10"
pushgateway_host: localhost
pushgateway_scheme: http
pushgateway_port: 9092
scaphandre_config_path: /etc/scaphandre/prometheuspush
service_name: scaphandre-prometheuspush
</code></pre>
<p>Ensure to change those to match your context, including changing rhel version if needed (8 and 9 are supported) and parameters to reach the Push Gateway on the network.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="explanations-about-host-level-power-and-energy-metrics"><a class="header" href="#explanations-about-host-level-power-and-energy-metrics">Explanations about host level power and energy metrics.</a></h1>
<p>This is true starting <strong>from Scaphandre &gt;= 1.0.</strong></p>
<p>There are several <a href="#metrics-exposed-by-scaphandre">metrics</a> available at the host level in Scaphandre:</p>
<ul>
<li><code>scaph_host_power_microwatts</code> : always returned, computed from Record structs made from <code>scaph_host_energy_microjoules</code> metric</li>
<li><code>scaph_host_energy_microjoules</code> : always returned, either one value or a sum of values coming directly from RAPL counters (<code>energy_uj</code> files or direct read from an MSR)</li>
<li><code>scaph_host_rapl_psys_microjoules</code> : is available only when the PSYS <a href="explanations/explanations/rapl-domains.html">RAPL domain</a> is available on the machine.</li>
</ul>
<p>In addition to those metrics, you might want to build, on your time series database, the sum of process_ metrics to have a view of the weight of all processes on the host power. Using Prometheus, it would look like: <code>sum(scaph_process_power_consumption_microwatts{hostname="$hostname"}) / 1000000</code>, to get it in Watts.</p>
<p>Let‚Äôs explain the relationship between those metrics, and what you could expect.</p>
<p><code>host_power</code> metric will return :</p>
<ol>
<li>If PSYS domain is available, a computed power coming from PSYS energy records</li>
<li>If not, a computed power which is the sum of per-socket power (PKG RAPL domain) + DRAM RAPL domain power</li>
</ol>
<p>Briefly explained (see <a href="explanations/explanations/rapl-domains.html">RAPL domains</a> for detailled explanations), PSYS covers most components on the machine (‚Äúall components connected to the SoC / motherboard‚Äù according to most documentations), so we return this wider ranged metric when available. If not we use a combination of PKG domain, that includes CPU and integrated GPU power, and DRAM domain, that includes memory power. The first options gives higher figures than the second, for now.</p>
<p>Suming the power of all processes, if the machine is mostly IDLE, you‚Äôll get a tiny percentage of the host machine, most likely. The difference between host power and the sum of processes power can be accounted as ‚Äúpower due to IDLE activity‚Äù, in other words the power your machine demands for ‚Äúdoing nothing‚Äù. The higher this difference on a long period of time (better seen as a graph), the higher chance that there is room for improvement in moving the workloads to another machine and shut the current machine down (and make it available for another project or to another organization to prevent from buying a new machine).</p>
<p><strong>Warning:</strong> that being said, the way per-process power is computed is still biased and shall be improved in the following versions of Scaphandre. For now, the main key for allocation is CPU time. As host level power metrics include power usage of more and more components on the machine (work in progress) this allocation key will be more and more inaccurate. Future versions of this allocation model should include keys regarding the activity of other components than CPU. Enabling a better set of allocation keys for per-process power is part of the <a href="https://github.com/hubblo-org/scaphandre/projects/1">roadmap</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-scaphandre-computes-per-process-power-consumption"><a class="header" href="#how-scaphandre-computes-per-process-power-consumption">How scaphandre computes per process power consumption</a></h1>
<p>Scaphandre is a tool that makes it possible to see the power being used by a single process on a computer.</p>
<p>This sounds like a simple thing to be able to do, but in practice a number of details can make this more complex.</p>
<p>So having a good mental model of how it works will make it easier to understand when and how to use Scaphandre. Let‚Äôs start with a simplified mental model below, before moving on to multiple processors or virtual machines - but once you understand the key ideas outlined below, it‚Äôs easier to see how they can be applied to thinking about tracking power on virtual machines, or when multiple processors are available.</p>
<h3 id="how-a-computer-works-on-multiple-jobs-at-the-same-time"><a class="header" href="#how-a-computer-works-on-multiple-jobs-at-the-same-time">How a computer works on multiple jobs at the same time</a></h3>
<p>When we first think about how much energy a single process running in a computer might use, we might start with a mental model that looks like the figure below, with large, uninterrupted chunks of compute time allocated to each process.</p>
<p>This is easy to understand, and it matches how we might be billed for a share of a larger machine when paying for cloud services.</p>
<p><img src="img/what-scaphandre-does.png" alt="what scaphandre does - per process power usage"></p>
<h4 id="timesharing-of-work"><a class="header" href="#timesharing-of-work">Timesharing of work</a></h4>
<p>However, if the reality was <em>exactly</em> like this diagram, our computers would only ever be able to do one thing at a time. It‚Äôs more accurate and helpful to think of computers working on lots of different jobs at the same time - they work on one job for short interval of time, then another, and another and so one. You‚Äôll often see these small intervals of time referred to as <em><a href="https://www.anshulpatel.in/posts/linux_cpu_percentage/">jiffies</a></em>.</p>
<p><img src="img/jiffies.png" alt="work on jobs is split into jiffies"></p>
<p>In a given amount of time, some jobs that are prioritized or more resource intensive will use more jiffies than others. Fortunately, each job keeps a running total of the total jiffies allocated to it, so if we know how many jiffies have been used in total, it can give us an idea how much of a machine‚Äôs resources are being used by a given process.</p>
<p><img src="img/total-time-share.png" alt="work on jobs is split into jiffies"></p>
<h3 id="going-from-share-of-resources-to-actual-power-figures"><a class="header" href="#going-from-share-of-resources-to-actual-power-figures">Going from share of resources to actual power figures</a></h3>
<p>It‚Äôs possible without Scaphandre to understand how large a share of a machines‚Äô resources are being used by a given process.</p>
<p>This is useful, by itself, but if we want to understand how much <em>power</em> is used per process, not just the share of the machine‚Äôs resources, we need to know how much power is being used by the machine in absolute terms.</p>
<p>To do this, we need a sensor of some kind to track power usage by the machine itself. Some servers have these, like with Intel‚Äôs RAPL sensors, which we cover in more detail later on. This makes it possible to understand how much power is being used by CPUs, GPUs and so on, in terms of watts, or, if we are looking at just a single process, various fractions of a watt.</p>
<p><img src="img/power-over-time.png" alt="Sensors provide power over time"></p>
<p>To understand the power used by a single process we combine both of these ideas. We count the jiffies used by <em>our</em> job when it‚Äôs being worked on, and for each jiffy, we check how much power is being drawn at those moments in time.</p>
<p><img src="img/power-and-share-of-usage.png" alt="Combined we can see how much the power during ‚Äòour‚Äô jiffies"></p>
<p>Finally, when we group together all the power readings for all our jiffies over a given time period, we can arrive at a usable figure for how much power has been used, in terms of watt hours.</p>
<p>Once we have a figure in terms of watt hours, there are various ways we can convert this to environmental impact. A common way is to use an <em>emission factor</em> for the electricity used, to turn the power consumption data into an estimate of associated carbon emissions.</p>
<p><img src="img/power-by-process.png" alt="Combined we can see how much the power during ‚Äòour‚Äô jiffies"></p>
<h3 id="working-with-virtualisation-and-multiple-processors"><a class="header" href="#working-with-virtualisation-and-multiple-processors">Working with virtualisation and multiple processors</a></h3>
<p>While the reality is again more complicated than the diagram below, the same ideas broadly apply when you introduce multiple processors too.</p>
<p>If you are able to read from sensors that can share how much power is being used by the various processors at work, and know how much of the time is being allocated to our processes during those moments, you can get a good idea of what these figures are, at a per-process level.</p>
<p><img src="img/multiple-processors.png" alt="Seeing this with multiple processors"></p>
<p>Things get a bit more complicated with virtualised environments, because in many cases, virtual machines only have a partial view of the system they are part of, and frequently do not have access to any power usage figures from the host physical machine.</p>
<p>However, if a guest virtual machine or guest container <em>does</em> have access to readings provided by the host physical machine, it is possible to work out the same kinds of per-process power figures. Scaphandre supports exposing these kinds of power readings to virtual machines and containers, which means, if you are running on infrastructure that is running scaphandre and exposing these readings, you can see these figures for the energy used by your own processes.</p>
<hr>
<h2 id="more-details-about-how-scaphandre-works"><a class="header" href="#more-details-about-how-scaphandre-works">More details about how Scaphandre works</a></h2>
<p>As you can see with the <a href="#prometheus-exporter">prometheus exporter reference</a>, scaphandre exporters can provide process level power consumption metrics. This section will explain how it is done and how it may be improved in the future.</p>
<h2 id="some-details-about-rapl"><a class="header" href="#some-details-about-rapl">Some details about RAPL</a></h2>
<p>We‚Äôll talk here about the case where scaphandre is able to effectively measure the power consumption of the host (see <a href="#compatibility">compatibility</a> section for more on sensors and their prerequisites) and specifically about the <a href="#powercap_rapl-sensor">PowercapRAPL</a> sensor.</p>
<p>Let‚Äôs clarify what‚Äôs happening when you collect metrics with scaphandre and the RAPL sensor.
RAPL stands for <a href="https://01.org/blogs/2014/running-average-power-limit-%E2%80%93-rapl">Running Average Power Limit</a>. It‚Äôs a technology embedded in most Intel and AMD x86 CPUs produced after 2012.</p>
<p>Thanks to this technology it is possible to get the total energy consumption of the CPU, of the consumption per CPU socket, plus in some cases, the consumption of the DRAM controller. In most cases it represents the vast majority of the energy consumption of the machine (except when running GPU intensive workloads, for example).</p>
<p>Further improvements shall be made in scaphandre to fully measure the consumption when GPU are involved (or a lot of hard drives on the same host‚Ä¶).</p>
<p>Between scaphandre and this data is the powercap kernel module that writes the energy consumption to files. Scaphandre reads those files, stores the data in buffers and then allows for more processing through the exporters.</p>
<h3 id="how-to-get-the-consumption-of-one-process-"><a class="header" href="#how-to-get-the-consumption-of-one-process-">How to get the consumption of one process ?</a></h3>
<p>The PowercapRAPL sensor does actually more than just collecting those energy consumption metrics (and converting them to power consumption metrics).</p>
<p>Every time the exporter asks for a measurement (either periodically like in the <a href="#stdout-exporter">Stdout</a> exporter, or every time a request comes as would be the case for the Prometheus exporter) the sensor reads the values of the energy counters from powercap. It then stores those values, and does the same for the CPU usage statistics of the CPU (the one you can see in <code>/proc/stats</code>) and for each running process on the machine at that time (see <code>/proc/PID/stats</code>).</p>
<p>With this data it is possible to compute the ratio of CPU time actively spent for a given PID on the CPU time actively spent doing something. With this ratio we can then get the subset of power consumption that is related to that PID on a given timeframe (between two measurement requests).</p>
<h3 id="how-to-get-the-consumption-of-an-applicationa-service-"><a class="header" href="#how-to-get-the-consumption-of-an-applicationa-service-">How to get the consumption of an application/a service ?</a></h3>
<p>Services and programs are often not running on only one PID. It‚Äôs needed to aggregate the consumption of all related PIDs to know what this service is actually consuming.</p>
<p>To do that, in the current state of scaphandre development, you can use the Prometheus exporter, and then use Prometheus and its query language capabilities. You‚Äôll find examples looking at the graphs and queries <a href="https://metrics.hubblo.org">here</a>. In a near future, more advanced features may be implemented in scaphandre to allow such classification even if you don‚Äôt have access to a proper <a href="https://en.wikipedia.org/wiki/Time_series_database">Time Series database (TSDB)</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="internal-structure"><a class="header" href="#internal-structure">Internal structure</a></h1>
<p>Scaphandre is designed to be extensible. As it performs basically two tasks: <strong>collecting</strong>/pre-computing the power consumption metrics and <strong>publishing</strong> it, it is composed of two main components: a <strong>sensor</strong> and an <strong>exporter</strong>. Each can be implemented in different ways to match a certain use case. When you run scaphandre from the command line, <code>-s</code> allows you to choose the sensor you want to use, and the next subcommand is the name of the exporter.</p>
<h2 id="sensors"><a class="header" href="#sensors">Sensors</a></h2>
<p>Sensors are meant to:</p>
<ol>
<li>get the power consumptions metrics of the host</li>
<li>make it available for the exporter</li>
</ol>
<p>The <a href="#powercap_rapl-sensor">PowercapRAPL</a> for instance, gets and transforms metrics coming from the powercap Linux kernel module, that serves as an interface to get the data from the <a href="https://01.org/blogs/2014/running-average-power-limit-%E2%80%93-rapl">RAPL</a> feature of x86 CPUs. Because this feature is only accessible when you are running on a bare metal machine, this sensor will not work in a virtual machine, except if you first run scaphandre on the hypervisor and make the VM metrics available, with the <a href="#qemu-exporter">qemu exporter</a>, to scaphandre running inside the virtual machine.</p>
<p>When you don‚Äôt have access to the hypervisor/bare-metal machine (ie. when you run on public cloud instances and your provider doesn‚Äôt run scaphandre) you still have the option to estimate the power consumption, based on both the ressources (cpu/gpu/ram/io‚Ä¶) consumed by the virtual machine at a given time, and the characteristics of the underlying hardware. This is the way we are designing the future <a href="https://github.com/hubblo-org/scaphandre/issues/25">estimation-based sensor</a>, to match that use case.</p>
<p>Looking at the code, you‚Äôll find that the interface between metrics and the exporters is in fact the <a href="https://docs.rs/scaphandre/0.1.1/scaphandre/sensors/struct.Topology.html">Topology</a> object. This is intended to be asked by the exporter through the <a href="https://docs.rs/scaphandre/0.1.1/scaphandre/sensors/trait.Sensor.html#tymethod.get_topology">get_topology</a> method of the sensor.</p>
<h2 id="exporters"><a class="header" href="#exporters">Exporters</a></h2>
<p>An exporter is expected to:</p>
<ol>
<li>ask the sensors to get new metrics and store them for later, potential usage</li>
<li>export the current metrics</li>
</ol>
<p>The <a href="#stdout-exporter">Stdout</a> exporter exposes the metrics on the standard output (in your terminal). The <a href="#prometheus-exporter">prometheus</a> exporter exposes the metrics on an HTTP endpoint, to be scraped by a <a href="https://prometheus.io">prometheus</a> instance. An exporter should be created for each monitoring scenario (do you want to feed your favorite monitoring/data analysis tool with scaphandre metrics ? feel free to open a <a href="https://github.com/hubblo-org/scaphandre/pulls">PR</a> to create a new exporter !).</p>
<p>As introduced in the <a href="#sensors">sensors</a> section, the <a href="#qemu-exporter">Qemu</a> exporter, is very specific. It is only intended to collect metrics related to running virtual machines on a Qemu/KVM hypervisor. Those metrics can then be made available to each virtual machine and their own scaphandre instance, running the <a href="#powercap_rapl-sensor">PowercapRAPL</a> sensor (with the <code>--vm</code> flag on). The qemu exporter puts VM‚Äôs metrics in files the same way the powercap kernel module does it. It mimics this behavior, so the sensor can act the same way it would on a bare metal machine.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="about-containers"><a class="header" href="#about-containers">About containers</a></h1>
<p>There are several ways scaphandre can interact with containers.</p>
<p>You may run scaphandre <strong>in a container</strong>, to not have to manage the dependencies, then measure the power consumption of the <strong>bare metal host</strong>. This is described in the <a href="#getting-started">quickstart tutorial</a>. Note that you need to expose <code>/sys/class/powercap</code> and <code>/proc</code> as volumes in the container to allow scaphandre to get the relevant metrics from the bare metal host.</p>
<p>Scaphandre may help you measure the <strong>power consumption of containers</strong> running on a given host. You can already get to that goal using the tips provided in the howto section called <a href="#get-process-level-power-consumption-in-my-grafana-dashboard">‚ÄúGet process level power consumption‚Äù</a>. It may still require some tweaking and inventiveness from you in making the approriate queries to your favorite TSDB. This should be made easier by the upcoming <a href="https://github.com/hubblo-org/scaphandre/projects/1">scaphandre features</a>.</p>
<p>Another use case scenario is measuring the power consumption of a <strong>container orchestrator</strong> (like <a href="https://kubernetes.io/">kubernetes</a>), its nodes and the containers and applications running on it. Scaphandre can be installed on Kubernetes via the Helm chart and there is a <a href="#kubernetes">tutorial</a> for installing it along with Prometheus and Grafana to view the metrics.</p>
<p>As described <a href="#compatibility">here</a>, scaphandre provides several ways (<a href="#sensors">sensors</a>) to collect the power consumption metrics. Depending on your use case a sensor should be more suitable than the other. Each of them comes with strengths and weaknesses. This is basically always a tradeoff between precision and simplicity. This is especially true if you run a container-based workloads on public cloud instances. We are working to provide a solution <a href="https://github.com/hubblo-org/scaphandre/issues/25">for that as well</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="explanation-on-rapl--running-average-power-limit-domains-what-we-think-we-know-so-far"><a class="header" href="#explanation-on-rapl--running-average-power-limit-domains-what-we-think-we-know-so-far">Explanation on RAPL / Running Average Power Limit domains: what we (think we) know so far</a></h1>
<p>RAPL stands for ‚ÄúRunning Average Power Limit‚Äù, it is a feature on Intel/AMD x86 CPU‚Äôs (manufactured after 2012) that allows to set limits on power used by the CPU and other components. This feature also allows to just get ‚Äúmeasurements‚Äù (mind the double quotes, as at least part of the numbers RAPL gives are coming from estimations/modeling) of components power usage.</p>
<p><img src="explanations/rapl.png" alt="RAPL domains"></p>
<p>It is composed of ‚Äúdomains‚Äù, that, in 2023, may include:</p>
<ul>
<li><strong>Core/PP0</strong>: Energy consumed by the CPU Cores themselves.</li>
<li><strong>Uncore/PP1</strong>: Energy consumed by components close to the CPU : most of the time it means the embedded GPU chipset.</li>
<li><strong>Dram</strong>: Energy consumed by the memory/RAM sticks</li>
<li><strong>Package/PKG</strong>: Includes ‚ÄúCore‚Äù and ‚ÄúUncore‚Äù. In some documentations and in some of our experiments it seem to include ‚ÄúDram‚Äù, but this doesn‚Äôt seem true in every cases.</li>
<li><strong>PSys</strong>: We don‚Äôt have a clear understanding on this one (yet). But most documentations refer to it with words similar to ‚ÄúPSys: (introduced with Intel Skylake) monitors and controls the thermal and power specifications of the entire SoC and it is useful especially when the source of the power consumption is neither the CPU nor the GPU. For multi-socket server systems, each socket reports its own RAPL values.‚Äù. To summarize, Psys seems like an interesting metric to get energy consumed by a motherboard and connected components (which includes RAPL usual suspects but also WiFi/Bluetooth cards and probably more). If you want to know more about this metric, we gathered references/sources <a href="https://github.com/bpetit/awesome-energy/tree/master#rapl-psys-domain">here</a>. If you want to help us understanding and documenting better this metric, please consider constributing to the <a href="https://github.com/Boavizta/Energizta/">Energizta project</a>.</li>
</ul>
<p>RAPL documentation from Intel doesn‚Äôt necessarily give very precise informations about how RAPL behaves depending on the platform, or about what is included in the calculation. Actively looking for other experimentations/feedbacks/documentations is needed. You might find some informations gathered here: <a href="https://github.com/bpetit/awesome-energy#rapl">awesome-energy</a>. If you have more or more precise informations and are willing to contribute, don‚Äôt hesitate to open a PR to dev branch on <a href="https://github.com/hubblo-org/scaphandre/tree/dev">scaphandre‚Äôs repository</a> (targeting <a href="https://github.com/hubblo-org/scaphandre/tree/dev/docs_src">docs_src folder</a>) and/or the <a href="https://github.com/bpetit/awesome-energy">awesome-energy</a> repository.</p>
<p>If you want to know if RAPL is supported by your CPU, please have a look to the end of the <a href="#compatibility">Compatibility</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="metrics-exposed-by-scaphandre"><a class="header" href="#metrics-exposed-by-scaphandre">Metrics exposed by Scaphandre</a></h1>
<p>With <a href="#stdout-exporter">Stdout</a> exporter, you can see all metrics available on your machine with flag <code>--raw-metrics</code>.
With <a href="#prometheus-exporter">prometheus</a> exporter, all metrics have a HELP section provided on /metrics (or whatever suffix you choosed to expose them).</p>
<p>Here are some key metrics that you will most probably be interested in:</p>
<ul>
<li><code>scaph_host_power_microwatts</code>: Aggregation of several measurements to give a try on the power usage of the the whole host, in microwatts (GAUGE). It might be the same as RAPL PSYS (see <a href="#explanation-on-rapl--running-average-power-limit-domains-what-we-think-we-know-so-far">RAPL domains</a>) measurement if available, or a combination of RAPL PKG and DRAM domains + an estimation of other hardware componentes power usage.</li>
<li><code>scaph_process_power_consumption_microwatts{exe="$PROCESS_EXE",pid="$PROCESS_PID",cmdline="path/to/exe --and-maybe-options"}</code>: Power consumption due to the process, measured on at the topology level, in microwatts. PROCESS_EXE being the name of the executable and PROCESS_PID being the pid of the process. (GAUGE)</li>
</ul>
<p>For more details on that metric labels, see <a href="#getting-per-process-data-with-scaph_process_-metrics">this section</a>.</p>
<p>And some more deep metrics that you may want if you need to make more complex calculations and data processing:</p>
<ul>
<li><code>scaph_host_energy_microjoules</code> : Energy measurement for the whole host, as extracted from the sensor, in microjoules. (COUNTER)</li>
<li><code>scaph_socket_power_microwatts{socket_id="$SOCKET_ID"}</code>: Power measurement relative to a CPU socket, in microwatts. SOCKET_ID being the socket numerical id (GAUGE)</li>
</ul>
<p>If your machine provides RAPL PSYS domain (see <a href="#explanation-on-rapl--running-average-power-limit-domains-what-we-think-we-know-so-far">RAPL domains</a>), you can get the raw energy counter for PSYS/platform with <code>scaph_host_rapl_psys_microjoules</code>. Note that <code>scaph_host_power_microwatts</code> is based on this PSYS counter if it is available.</p>
<p>Since 1.0.0 the following host metrics are availalable as well ;</p>
<ul>
<li><code>scaph_host_swap_total_bytes</code>: Total swap space on the host, in bytes.</li>
<li><code>scaph_host_swap_free_bytes</code>: Swap space free to be used on the host, in bytes.</li>
<li><code>scaph_host_memory_free_bytes</code>: Random Access Memory free to be used (not reused) on the host, in bytes.</li>
<li><code>scaph_host_memory_available_bytes</code>: Random Access Memory available to be re-used on the host, in bytes.</li>
<li><code>scaph_host_memory_total_bytes</code>: Random Access Memory installed on the host, in bytes.</li>
<li><code>scaph_host_disk_total_bytes</code>: Total disk size, in bytes.</li>
<li><code>scaph_host_disk_available_bytes</code>: Available disk space, in bytes.</li>
</ul>
<p>Disk metrics have the following labels : disk_file_system, disk_is_removable, disk_type, disk_mount_point, disk_name</p>
<ul>
<li><code>scaph_host_cpu_frequency</code>: Global frequency of all the cpus. In MegaHertz</li>
<li><code>scaph_host_load_avg_fifteen</code>: Load average on 15 minutes.</li>
<li><code>scaph_host_load_avg_five</code>: Load average on 5 minutes.</li>
<li><code>scaph_host_load_avg_one</code>: Load average on 1 minute.</li>
</ul>
<p>If you hack scaph or just want to investigate its behavior, you may be interested in some internal metrics:</p>
<ul>
<li>
<p><code>scaph_self_memory_bytes</code>: Scaphandre memory usage, in bytes</p>
</li>
<li>
<p><code>scaph_self_memory_virtual_bytes</code>: Scaphandre virtual memory usage, in bytes</p>
</li>
<li>
<p><code>scaph_self_topo_stats_nb</code>: Number of CPUStat traces stored for the host</p>
</li>
<li>
<p><code>scaph_self_topo_records_nb</code>: Number of energy consumption Records stored for the host</p>
</li>
<li>
<p><code>scaph_self_topo_procs_nb</code>: Number of processes monitored by scaph</p>
</li>
<li>
<p><code>scaph_self_socket_stats_nb{socket_id="SOCKET_ID"}</code>: Number of CPUStat traces stored for each socket</p>
</li>
<li>
<p><code>scaph_self_socket_records_nb{socket_id="SOCKET_ID"}</code>: Number of energy consumption Records stored for each socket, with SOCKET_ID being the id of the socket measured</p>
</li>
<li>
<p><code>scaph_self_domain_records_nb{socket_id="SOCKET_ID",rapl_domain_name="RAPL_DOMAIN_NAME "}</code>: Number of energy consumption Records stored for a Domain, where SOCKET_ID identifies the socket and RAPL_DOMAIN_NAME identifies the rapl domain measured on that socket</p>
</li>
</ul>
<h3 id="getting-per-process-data-with-scaph_process_-metrics"><a class="header" href="#getting-per-process-data-with-scaph_process_-metrics">Getting per process data with scaph_process_* metrics</a></h3>
<p>Here are available labels for the <code>scaph_process_power_consumption_microwatts</code> metric that you may need to extract the data you need:</p>
<ul>
<li><code>exe</code>: is the name of the executable that is the origin of that process. This is good to be used when your application is running one or only a few processes.</li>
<li><code>cmdline</code>: this contains the whole command line with the executable path and its parameters (concatenated). You can filter on this label by using prometheus <code>=~</code> operator to match a regular expression pattern. This is very practical in many situations.</li>
<li><code>instance</code>: this is a prometheus generated label to enable you to filter the metrics by the originating host. This is very useful when you monitor distributed services, so that you can not only sum the metrics for the same service on the different hosts but also see what instance of that service is consuming the most, or notice differences beteween hosts that may not have the same hardware, and so on‚Ä¶</li>
<li><code>pid</code>: is the process id, which is useful if you want to track a specific process and have your eyes on what‚Äôs happening on the host, but not so practical to use in a more general use case</li>
</ul>
<p>Since 1.0.0 the following per-process metrics are available as well :</p>
<ul>
<li><code>scaph_process_cpu_usage_percentage</code>: CPU time consumed by the process, as a percentage of the capacity of all the CPU Cores</li>
<li><code>scaph_process_memory_bytes</code>: Physical RAM usage by the process, in bytes</li>
<li><code>scaph_process_memory_virtual_bytes</code>: Virtual RAM usage by the process, in bytes</li>
<li><code>scaph_process_disk_total_write_bytes</code>: Total data written on disk by the process, in bytes</li>
<li><code>scaph_process_disk_write_bytes</code>: Data written on disk by the process, in bytes</li>
<li><code>scaph_process_disk_read_bytes</code>: Data read on disk by the process, in bytes</li>
<li><code>scaph_process_disk_total_read_bytes</code>: Total data read on disk by the process, in bytes</li>
</ul>
<h3 id="get-container-specific-labels-on-scaph_process_-metrics"><a class="header" href="#get-container-specific-labels-on-scaph_process_-metrics">Get container-specific labels on scaph_process_* metrics</a></h3>
<p>The flag ‚Äìcontainers enables Scaphandre to collect data about the running Docker containers or Kubernetes pods on the local machine. This way, it adds specific labels to make filtering processes power consumption metrics by their encapsulation in containers easier.</p>
<p>Generic labels help to identify the container runtime and scheduler used (based on the content of <code>/proc/PID/cgroup</code>):</p>
<p><code>container_scheduler</code>: possible values are <code>docker</code> or <code>kubernetes</code>. If this label is not attached to the metric, it means that scaphandre didn‚Äôt manage to identify the container scheduler based on cgroups data.</p>
<p>Then the label <code>container_runtime</code> could be attached. The only possible value for now is <code>containerd</code>.</p>
<p><code>container_id</code> is the ID scaphandre got from /proc/PID/cgroup for that container.</p>
<p>For Docker containers (if <code>container_scheduler</code> is set), available labels are :</p>
<ul>
<li><code>container_names</code>: is a string containing names attached to that container, according to the docker daemon</li>
<li><code>container_docker_version</code>: version of the docker daemon</li>
<li><code>container_label_maintainer</code>: content of the maintainer field for this container</li>
</ul>
<p>For containers coming from a docker-compose file, there are a bunch of labels related to data coming from the docker daemon:</p>
<ul>
<li><code>container_label_com_docker_compose_project_working_dir</code></li>
<li><code>container_label_com_docker_compose_container_number</code></li>
<li><code>container_label_com_docker_compose_project_config_files</code></li>
<li><code>container_label_com_docker_compose_version</code></li>
<li><code>container_label_com_docker_compose_service</code></li>
<li><code>container_label_com_docker_compose_oneoff</code></li>
</ul>
<p>For Kubernetes pods (if <code>container_scheduler</code> is set), available labels are :</p>
<ul>
<li><code>kubernetes_node_name</code>: identifies the name of the kubernetes node scaphandre is running on</li>
<li><code>kubernetes_pod_name</code>: the name of the pod the container belongs to</li>
<li><code>kubernetes_pod_namespace</code>: the namespace of the pod the container belongs to</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="json-exporter"><a class="header" href="#json-exporter">JSON exporter</a></h1>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>You can launch the JSON exporter this way (running the default powercap_rapl sensor):</p>
<pre><code>scaphandre json
</code></pre>
<p>Default behavior is to measure and show metrics periodically during 10 seconds. You can change that timeout with <code>-t</code>. Here is how to display metrics during one minute:</p>
<pre><code>scaphandre json -t 60
</code></pre>
<p>You can change as well the step measure duration with -s. Here is how to display metrics during one minutes with a 5s step:</p>
<pre><code>scaphandre json -t 60 -s 5
</code></pre>
<p>If you want a faster interval you can use option -n (for nano seconds). Here is how to display metrics during 10s with a 100ms step:</p>
<pre><code>scaphandre json -t 10 -s 0 -n 100000000
</code></pre>
<p>By default, JSON is printed in the terminal, to write result in a file you can provide a path with option -f:</p>
<pre><code>scaphandre json -t 10 -s 0 -n 100000000 -f report.json
</code></pre>
<p>To get informations about processes that are running in containers, add <code>--containers</code>:</p>
<pre><code>scaphandre --no-header json --containers --max-top-consumers=15 | jq
</code></pre>
<p>Since 1.0.0 you can filter the processes, either by their process name with <code>--process-regex</code>, or by the name of the container they run in with <code>--container-regex</code> (needs the flag <code>--containers</code> to be active as well).</p>
<p>As always exporter‚Äôs options can be displayed with <code>-h</code>:</p>
<pre><code>Write the metrics in the JSON format to a file or to stdout

Usage: scaphandre json [OPTIONS]

Options:
  -t, --timeout &lt;TIMEOUT&gt;
          Maximum time spent measuring, in seconds. If unspecified, runs forever
  -s, --step &lt;SECONDS&gt;
          Interval between two measurements, in seconds [default: 2]
      --step-nano &lt;NANOSECS&gt;
          Additional step duration in _nano_ seconds. This is added to `step` to get the final duration [default: 0]
      --max-top-consumers &lt;MAX_TOP_CONSUMERS&gt;
          Maximum number of processes to watch [default: 10]
  -f, --file &lt;FILE&gt;
          Destination file for the report (if absent, print the report to stdout)
      --containers
          Monitor and apply labels for processes running as containers
      --process-regex &lt;PROCESS_REGEX&gt;
          Filter processes based on regular expressions (example: 'scaph\\w\\w.e')
      --container-regex &lt;CONTAINER_REGEX&gt;
          Filter containers based on regular expressions
      --resources
          Monitor and incude CPU, RAM and Disk usage per process
  -h, --help
          Print help
</code></pre>
<p>Metrics provided Scaphandre are documented <a href="#metrics-exposed-by-scaphandre">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="prometheus-exporter"><a class="header" href="#prometheus-exporter">Prometheus exporter</a></h1>
<img src="https://github.com/hubblo-org/scaphandre/raw/main/docs_src/screen-prometheus.cleaned.png">
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>You can launch the prometheus exporter this way (running the default powercap_rapl sensor):</p>
<pre><code>scaphandre prometheus
</code></pre>
<p>As always exporter‚Äôs options can be displayed with <code>-h</code>:</p>
<pre><code>	scaphandre prometheus -h
	scaphandre-prometheus
	Prometheus exporter exposes power consumption metrics on an http endpoint (/metrics is default) in prometheus accepted
	format

	USAGE:
		scaphandre prometheus [FLAGS] [OPTIONS]

	FLAGS:
        --containers    Monitor and apply labels for processes running as containers
		-h, --help       Prints help information
		-q, --qemu       Instruct that scaphandre is running on an hypervisor
		-V, --version    Prints version information

	OPTIONS:
		-a, --address &lt;address&gt;    ipv6 or ipv4 address to expose the service to [default: ::]
		-p, --port &lt;port&gt;          TCP port number to expose the service [default: 8080]
		-s, --suffix &lt;suffix&gt;      url suffix to access metrics [default: metrics]
</code></pre>
<p>With default options values, the metrics are exposed on http://localhost:8080/metrics.</p>
<p>Use -q or ‚Äìqemu option if you are running scaphandre on a hypervisor. In that case a label with the vm name will be added to all <code>qemu-system*</code> processes.
This will allow to easily create charts consumption for each vm and defined which one is the top contributor.</p>
<p>Metrics provided Scaphandre are documented <a href="#metrics-exposed-by-scaphandre">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="prometheuspush-exporter-for-prometheus-push-gateway"><a class="header" href="#prometheuspush-exporter-for-prometheus-push-gateway">PrometheusPush Exporter for Prometheus Push Gateway</a></h1>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>You can launch the prometheus exporter this way:</p>
<pre><code>scaphandre prometheus-push
</code></pre>
<p>As always exporter‚Äôs options can be displayed with <code>-h</code>:</p>
<pre><code>	scaphandre prometheus-push -h
	Push metrics to Prometheus Push Gateway

	Usage: scaphandre prometheus-push [OPTIONS]

	Options:
	  -H, --host &lt;HOST&gt;      IP address (v4 or v6) of the metrics endpoint for Prometheus [default: localhost]
	  -p, --port &lt;PORT&gt;      TCP port of the metrics endpoint for Prometheus [default: 9091]
	      --suffix &lt;SUFFIX&gt;  [default: metrics]
	  -S, --scheme &lt;SCHEME&gt;  [default: http]
	  -s, --step &lt;STEP&gt;      [default: 5]
	      --qemu             Apply labels to metrics of processes that look like a Qemu/KVM virtual machine
	      --containers       Apply labels to metrics of processes running as containers
	  -j, --job &lt;JOB&gt;        Job name to apply as a label for pushed metrics [default: scaphandre]
	      --no-tls-check     Don't verify remote TLS certificate (works with --scheme="https")
	  -h, --help             Print help
</code></pre>
<p>With default options values, the metrics are sent to http://localhost:9091/metrics</p>
<h2 id="metrics-exposed"><a class="header" href="#metrics-exposed">Metrics exposed</a></h2>
<p>Metrics exposed are the same as the Prometheus (pull mode) exporter.</p>
<p>Push gateway‚Äôs grouping key for each host is in the form <code>job/scaphandre/instance/${HOSTNAME}</code> with HOSTNAME being the hostname of the host sending metrics.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="qemu-exporter"><a class="header" href="#qemu-exporter">Qemu exporter</a></h1>
<p>Computes energy consumption metrics for each Qemu/KVM virtual machine found on the host.
Exposes those metrics as filetrees compatible with the <a href="#powercap_rapl-sensor">powercap_rapl sensor</a>.</p>
<p>Note that this is still experimental. Metrics are already considered trustworthy, but there are discussions and tests to be performed about the acceptable ways to share the data with the guests/vms. Any feedback or thoughts about this are welcome. Please refer to the <a href="#contributing-guide">contributing section</a>.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<ol>
<li>
<p>Run the scaphandre with the qemu exporter on your bare metal hypervisor machine:</p>
<pre><code> scaphandre qemu # this is suitable for a test, please run it as a systemd service for a production setup
</code></pre>
</li>
<li>
<p>Default is to expose virtual machines metrics in <code>/var/lib/libvirt/scaphandre/${DOMAIN_NAME}</code> with <code>DOMAIN_NAME</code> being the libvirt domain name of the virtual machine.
First create a tmpfs mount point to isolate metrics for that virtual machine:</p>
<pre><code> mount -t tmpfs tmpfs_DOMAIN_NAME /var/lib/libvirt/scaphandre/DOMAIN_NAME -o size=10m
</code></pre>
</li>
<li>
<p>Ensure you expose the content of this folder to the virtual machine by having this configuration in the xml configuration of the domain:</p>
<pre><code>		&lt;filesystem type='mount' accessmode='passthrough'&gt;
	      &lt;driver type='virtiofs'/&gt;
	      &lt;source dir='/var/lib/libvirt/scaphandre/DOMAIN_NAME'/&gt;
	      &lt;target dir='scaphandre'/&gt;
		  &lt;readonly /&gt;
	    &lt;/filesystem&gt;
</code></pre>
<p>You can edit the vm properties using <code>sudo virsh edit &lt;DOMAIN_NAME&gt;</code> using your usual editor. But it is more convenient to use virtual-manager, as explained in the following screenshots.</p>
<p><em>It also helps to define the correct syntax which probably depends from the qemu version. You can check that the above configuration is slightly different form the one below</em>.</p>
<p>a. Right click in the hardware menu:
<img src="references/images/virtualmgr00.png" alt="virtualmgr00"></p>
<p>b. Enter the following parameters:
<img src="references/images/virtualmgr01.png" alt="virtualmgr01"></p>
<p>c. XML generated as a result:
<img src="references/images/virtualmgr02.png" alt="virtualmgr02"></p>
<ol start="4">
<li>
<p>Ensure the VM has been started once the configuration is applied, then mount the filesystem on the VM/guest:</p>
<pre><code> mount -t 9p -o trans=virtio scaphandre /var/scaphandre
</code></pre>
</li>
<li>
<p>Still in the guest, run scaphandre in VM mode with the default sensor:</p>
<pre><code> scaphandre --vm prometheus
</code></pre>
</li>
<li>
<p>Collect your virtual machine specific power usage metrics. (requesting http://VM_IP:8080/metrics in this example, using the prometheus exporter)</p>
</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riemann-exporter"><a class="header" href="#riemann-exporter">Riemann exporter</a></h1>
<p><img src="references/images/riemann_exporter.png" alt="riemann exporter"></p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<p>You can launch the Riemann exporter this way (running the default powercap_rapl sensor):</p>
<pre><code>scaphandre riemann
</code></pre>
<p>As always exporter‚Äôs options can be displayed with <code>-h</code>:</p>
<pre><code>Expose the metrics to a Riemann server

Usage: scaphandre riemann [OPTIONS]

Options:
  -a, --address &lt;ADDRESS&gt;
          Address of the Riemann server. If mTLS is used this must be the server's FQDN [default: localhost]
  -p, --port &lt;PORT&gt;
          TCP port number of the Riemann server [default: 5555]
  -d, --dispatch-interval &lt;DISPATCH_INTERVAL&gt;
          Duration between each metric dispatch, in seconds [default: 5]
  -q, --qemu
          Apply labels to metrics of processes looking like a Qemu/KVM virtual machine
      --containers
          Monitor and apply labels for processes running as containers
      --mtls
          Connect to Riemann using mTLS instead of plain TCP
      --ca &lt;CA_FILE&gt;
          CA certificate file (.pem format)
      --cert &lt;CERT_FILE&gt;
          Client certificate file (.pem format)
      --key &lt;KEY_FILE&gt;
          Client RSA key file
  -h, --help
          Print help
</code></pre>
<p>With default options values, the metrics are sent to http://localhost:5555 every 5 seconds</p>
<p>Use <code>--mtls</code> option to connect to a Riemann server using mTLS. In such case, you must provide the following parameters:</p>
<ul>
<li><code>--address</code> to specify the <strong>fqdn</strong> of the Riemann server.</li>
<li><code>--ca</code> to specify the CA that authenticate the Riemann server.</li>
<li><code>--cert</code> to specify the client certificate.</li>
<li><code>--key</code> to specify the <strong>RSA</strong> key to be used by the client certificate.</li>
</ul>
<p>Use <code>-q</code> or <code>--qemu</code> option if you are running scaphandre on a hypervisor. In that case a label with the vm name will be added to all <code>qemu-system*</code> processes.
This will allow to easily create charts consumption for each vm and defined which one is the top contributor.</p>
<p><em>Troubleshooting note:</em> run  Scaphandre using <code>-vv</code> parameter. If Scaphandre is stuck on the <code>Send data</code> log event, ensure you are connecting the Riemann server using a TLS port (5554 in the below example).
As a reference here is a Riemann configuration:</p>
<pre><code>; -*- mode: clojure; -*-
; vim: filetype=clojure

(logging/init {:file "riemann.log"})

; Listen on the local interface over TCP (5555), UDP (5555), TLS/TCP (5554)  and websockets
; (5556)
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (tcp-server {:host host
               :port 5554
               :tls? true
               :key "/client.key.pkcs8"
               :cert "/client.pem"
               :ca-cert "/CA.pem"})
  (udp-server {:host host})
  (ws-server  {:host host}))

; Expire old events from the index every 5 seconds.
(periodically-expire 5)

(let [index (index)]
  ; Inbound events will be passed to these streams:
  (streams
    (default :ttl 60
      ; Index all events immediately.
      index

      ; Log expired events.
      (expired
        (fn [event] (info "expired" event))))))
</code></pre>
<h2 id="metrics-exposed-1"><a class="header" href="#metrics-exposed-1">Metrics exposed</a></h2>
<p>Metrics provided Scaphandre are documented <a href="#metrics-exposed-by-scaphandre">here</a>.</p>
<p>There is only one exception about <code>process_power_consumption_microwatts</code> each process has a service name <code>process_power_consumption_microwatts_pid_exe</code>.</p>
<p>As an example, process consumption can be retrieved using the following Riemann query:</p>
<pre><code>(service =~ "process_power_consumption_microwatts_%_firefox") or (service =~ "process_power_consumption_microwatts_%_scaphandre")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdout-exporter"><a class="header" href="#stdout-exporter">Stdout exporter</a></h1>
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<p>You can launch the stdout exporter this way (running the default powercap_rapl sensor):</p>
<pre><code>scaphandre stdout
</code></pre>
<p>Default behavior is to measure and show metrics periodically during 10 seconds. You can change that timeout with <code>-t</code>.
A value of <code>-t 0</code> will display top consumers infinitely and must be interrupted with ctrl-c.</p>
<p>Here is how to display metrics during one minute:</p>
<pre><code>scaphandre stdout -t 60
</code></pre>
<p>You can change as well the step measure duration with <code>-s</code>. Here is how to display metrics during one minutes with a 5s step:</p>
<pre><code>scaphandre stdout -t 60 -s 5
</code></pre>
<p>You can change the number of top consumers displayed with <code>-p</code>. Here is how to display the first 20 top consumers:</p>
<pre><code>scaphandre stdout -p 20
</code></pre>
<p>You can filter the processes to display with <code>-r</code>. A warning will be risen if this option is used with <code>-p</code> at the same time.
In such case, <code>-p</code> behavior is disabled.</p>
<p>The <code>-r</code> expected parameter is a regular expression. Details can be found <a href="https://docs.rs/regex/1.4.5/regex/#syntax">here</a> and tested <a href="https://rustexp.lpil.uk/">here</a>.</p>
<p>Here is how to display power data for the ‚Äòscaphandre‚Äô process:</p>
<pre><code>scaphandre stdout -r 'scaphandre'
</code></pre>
<p>Metrics provided Scaphandre are documented <a href="references/references/metrics.html">here</a>.</p>
<p>Since 1.0.0 the flag <code>--raw-metrics</code> displays all metrics available for the host, as a parseable list. This might be useful to list metrics that you would like to fetch afterwards in your monitoring dashboard. Without this flag enabled, Stdout exporter has it‚Äôs own format and might not show you all available metrics.</p>
<p>As always exporter‚Äôs options can be displayed with <code>-h</code>:</p>
<pre><code>Write the metrics to the terminal

Usage: scaphandre stdout [OPTIONS]

Options:
  -t, --timeout &lt;TIMEOUT&gt;            Maximum time spent measuring, in seconds. If negative, runs forever [default: 10]
  -s, --step &lt;SECONDS&gt;               Interval between two measurements, in seconds [default: 2]
  -p, --processes &lt;PROCESSES&gt;        Maximum number of processes to display [default: 5]
  -r, --regex-filter &lt;REGEX_FILTER&gt;  Filter processes based on regular expressions (example: 'scaph\\w\\w.e')
      --containers                   Monitor and apply labels for processes running as containers
  -q, --qemu                         Apply labels to metrics of processes looking like a Qemu/KVM virtual machine
      --raw-metrics                  Display metrics with their names
  -h, --help                         Print help</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="warp10-exporter"><a class="header" href="#warp10-exporter">Warp10 exporter</a></h1>
<p><img src="references/images/warp10.png" alt="warp10 exporter"></p>
<h2 id="usage-6"><a class="header" href="#usage-6">Usage</a></h2>
<p>You can launch the Warp10 exporter this way (running the default powercap_rapl sensor):</p>
<pre><code>scaphandre warp10
</code></pre>
<p>You need a token to be able to push data to a <a href="https://warp10.io">warp10</a> instance.
The <code>SCAPH_WARP10_WRITE_TOKEN</code> env var can be used to make it available to scaphandre.
Please refer to the warp10 documentation to know how to get the token in the first place.</p>
<p>As always exporter‚Äôs options can be displayed with <code>-h</code>:</p>
<pre><code>Expose the metrics to a Warp10 host, through HTTP

Usage: scaphandre warpten [OPTIONS]

Options:
  -H, --host &lt;HOST&gt;                FQDN or IP address of the Warp10 instance [default: localhost]
  -p, --port &lt;PORT&gt;                TCP port of the Warp10 instance [default: 8080]
  -S, --scheme &lt;SCHEME&gt;            "http" or "https" [default: http]
  -t, --write-token &lt;WRITE_TOKEN&gt;  Auth token to write data to Warp10. If not specified, you must set the env variable SCAPH_WARP10_WRITE_TOKEN
  -s, --step &lt;SECONDS&gt;             Interval between two measurements, in seconds [default: 2]
  -q, --qemu                       Apply labels to metrics of processes looking like a Qemu/KVM virtual machine
  -h, --help                       Print help
</code></pre>
<p>With default options values, the metrics are sent to http://localhost:8080 every 60 seconds</p>
<p>Use -q or ‚Äìqemu option if you are running scaphandre on a hypervisor. In that case a label with the vm name will be added to all <code>qemu-system*</code> processes.
This will allow to easily create charts consumption for each vm and defined which one is the top contributor.</p>
<p>Metrics provided Scaphandre are documented <a href="#metrics-exposed-by-scaphandre">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="msr_rapl-sensor"><a class="header" href="#msr_rapl-sensor">MSR_RAPL sensor</a></h1>
<h2 id="pre-requesites"><a class="header" href="#pre-requesites">Pre-requesites</a></h2>
<p>At the time those lines are written, this sensor works only on:</p>
<ul>
<li>OS: Windows 10/Windows Server 2016, Windows Server 2019</li>
<li>Intel and AMD x86 CPUs, produced after 2012 (or some laptop cpu prior to 2012)</li>
</ul>
<p>This sensor needs the <a href="https://github.com/hubblo-org/windows-rapl-driver/">RAPL MSR-based driver</a> to be installed.</p>
<h2 id="usage-7"><a class="header" href="#usage-7">Usage</a></h2>
<p>To explicitely call the powercap_rapl sensor from the command line use:</p>
<pre><code>scaphandre -s msr_rapl EXPORTER # EXPORTER being the exporter name you want to use
</code></pre>
<p>You can see arguments available from the cli for this sensors with:</p>
<pre><code>scaphandre -s msr_rapl -h
</code></pre>
<p>Please refer to doc.rs code documentation for more details.</p>
<h2 id="options-available"><a class="header" href="#options-available">Options available</a></h2>
<p>TODO</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h2>
<p>TODO</p>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powercap_rapl-sensor"><a class="header" href="#powercap_rapl-sensor">Powercap_rapl sensor</a></h1>
<h2 id="pre-requesites-1"><a class="header" href="#pre-requesites-1">Pre-requesites</a></h2>
<p>At the time those lines are written, this sensor works only on:</p>
<ul>
<li>OS: GNU/Linux</li>
<li>Intel and AMD x86 CPUs, produced after 2012 (or some laptop cpu prior to 2012)</li>
</ul>
<p>It needs the following kernel modules to be present and running:</p>
<p>On kernels 5.0 or later: <code>intel_rapl_common</code></p>
<p>On kernel prior 5.0: <code>intel_rapl</code></p>
<p>For AMD processors, it seems that powercap/rapl <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Google-Zen-RAPL-PowerCap">will work only since kernel 5.8</a>
and <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=AMD-RAPL-Linux-Now-19h">5.11 for family 19h</a>.</p>
<p>Energy consumption data can be directly collected on a <strong>physical machine</strong> only.</p>
<p>To collect energy consumption on a virtual machine, you may first collect power consumption data from the hypervisor thanks to the <a href="#qemu-exporter">qemu exporter</a> and then collect those metrics in the virtual machine thanks to this sensor, with <code>--vm</code> flag enabled.</p>
<h2 id="usage-8"><a class="header" href="#usage-8">Usage</a></h2>
<p>To explicitely call the powercap_rapl sensor from the command line use:</p>
<pre><code>scaphandre -s powercap_rapl EXPORTER # EXPORTER being the exporter name you want to use
</code></pre>
<p>You can see arguments available from the cli for this sensors with:</p>
<pre><code>scaphandre -s powercap_rapl -h
</code></pre>
<p>If running in a virtual machine:</p>
<pre><code>scaphandre --vm -s powercap_rapl EXPORTER
</code></pre>
<p>Please refer to doc.rs code documentation for more details.</p>
<h2 id="options-available-1"><a class="header" href="#options-available-1">Options available</a></h2>
<ul>
<li><code>sensor-buffer-per-socket-max-kB</code>: Maximum memory size allowed, in KiloBytes, for storing energy consumption for each socket</li>
<li><code>sensor-buffer-per-domain-max-kB</code>: Maximum memory size allowed, in KiloBytes, for storing energy consumption for each domain</li>
</ul>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment variables</a></h2>
<p>If in <code>--vm</code> mode, you want to read metrics from another path than the default <code>/var/scaphandre</code>, set env var <code>SCAPHANDRE_POWERCAP_PATH</code> with the desired path.</p>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="when-running-scaphandre-on-ubuntu-20xx-i-get-a-permission-denied-error"><a class="header" href="#when-running-scaphandre-on-ubuntu-20xx-i-get-a-permission-denied-error">When running scaphandre on Ubuntu 20.xx I get a <code>permission denied</code> error</a></h3>
<p>Since linux kernel package 5.4.0-53.59 in debian/ubuntu, powercap attributes are only accessible by root:</p>
<pre><code>linux (5.4.0-53.59) focal; urgency=medium

  * CVE-2020-8694
    - powercap: make attributes only readable by root
</code></pre>
<p>Therefor, the user running scaphandre needs to have read access to <em>energy_uj</em> files in <code>/sys/class/powercap</code>.</p>
<p>You can run the <a href="../init.sh">init.sh</a> script to apply appropriate permissions to the required files.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="why-"><a class="header" href="#why-">Why ?</a></h1>
<p>We are facing the biggest challenge of mankind history: to make our activities sustainable enough to not jeopardize our future.</p>
<p><img src="https://bpetit.nce.re/temperature-anomaly.svg" alt="Global average temperature anomaly"></p>
<p>To match the Paris agreement objective of not going further than +2 Celcius degrees on average in 2100, we need to transform our industries.
The tech industry is no exception and we need to make sure that its benefits are not cancelled (or worse) by its negative impact.</p>
<p>Measuring power consumption in tech services infrastructures is not as easy as it seems. We often rely on physical devices to do that and need to build in-house data pipelines to get those metrics useful. Furthermore this doesn‚Äôt give fine-grained data regarding applications/processes power consumption but only the host power consumption.
This is even harder in a virtualization environment or as public cloud customers.</p>
<p>Even <a href="https://www.iea.org/reports/data-centres-and-data-transmission-networks">recent</a> <a href="https://www.actu-environnement.com/media/pdf/news-36483-etude-UE-consommation-energie-centre-donnees-cloud.pdf">scientific</a> researches about tech energy consumption rely on statistical, both large and narrowed scale, assumptions-based data (because it‚Äôs all we‚Äôve got). Despite their weaknesses, they also all agree on the fact that the current consumption of datacenters and the Internet will increase drastically in the following years.</p>
<p>Scaphandre aims to initiate a collaboration of tech companies and enthusiasts to provide an easy, lightweight, robust and well-understood way to precisely measure the energy consumption and make it useful to take soberness decisions.</p>
<p>Note that the greenhouse gas emissions related to this energy consumption depends on the energy mix of your country. You may find valuable data about that on <a href="https://www.electricitymap.org/map">Electricity Map</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h1>
<p>Scaphandre intends to provide multiple ways to gather power consumption metrics and make understanding tech services footprint possible in many situations. Depending on how you use scaphandre, you may have some restrictions.</p>
<p>To summarize, scaphandre should provide two ways to estimate the power consumption of a service, process or machine. Either by <strong>measuring it</strong>, using software interfaces that give access to hardware metrics, or by <strong>estimating it</strong> if measuring is not an option (this is a <a href="https://github.com/hubblo-org/scaphandre/issues/25">planned feature</a>, not yet implemented as those lines are written, in december 2020).</p>
<p>In scaphandre, the code responsible to collect the power consumption data before any further processing is grouped in components called <strong>sensors</strong>. If you want more details about scaphandre structure, <a href="#internal-structure">here are the explanations</a>.</p>
<p>On GNU/Linux <a href="#powercap_rapl-sensor">PowercapRAPL sensor</a> enables you to measure the power consumption, but it doesn‚Äôt work in all contexts.</p>
<p>On Windows, <a href="#msr_rapl-sensor">the MsrRAPL sensor</a>, coupled with the <a href="https://github.com/hubblo-org/windows-rapl-driver/">driver responsible to read RAPL MSR‚Äôs</a> enables you to do (almost) the same.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Sensor</th><th style="text-align: center">Intel x86 bare metal</th><th style="text-align: center">AMD x86 bare metal</th><th style="text-align: center">ARM bare metal</th><th style="text-align: center">Virtual Machine</th><th style="text-align: center">Public cloud instance</th><th style="text-align: center">Container</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left">PowercapRAPL (GNU/Linux only)</td><td style="text-align: center"><a href="#powercap_rapl-sensor">Yes</a></td><td style="text-align: center">Yes ‚ö†Ô∏è  kernel &gt; 5.11 required</td><td style="text-align: center">We don‚Äôt know yet</td><td style="text-align: center">Yes, if on a qemu/KVM hypervisor that runs scaphandre and the <a href="#qemu-exporter">Qemu exporter</a></td><td style="text-align: center">No, until your cloud provider uses scaphandre on its hypervisors</td><td style="text-align: center"><a href="#about-containers">Depends on what you want</a></td></tr>
<tr><td style="text-align: left">MsrRAPL (Windows only)</td><td style="text-align: center">Yes</td><td style="text-align: center">Probable yes (not tested yet, if you have windows operated AMD gear, please consider <a href="#contributing-guide">contributing</a></td><td style="text-align: center">No</td><td style="text-align: center">Not yet, depends on improvements on the MsrRAPL sensors and overall windows/hypervisors support in Scaphandre</td><td style="text-align: center">No, until your cloud provider uses scaphandre on its hypervisors</td><td style="text-align: center">Might work, not tested yet. If you want to join us in this journey, please consider <a href="#contributing-guide">contributing</a></td></tr>
<tr><td style="text-align: left">Future estimation based sensor</td><td style="text-align: center">Future Yes</td><td style="text-align: center">Future Yes</td><td style="text-align: center">Future Yes</td><td style="text-align: center">Future Yes</td><td style="text-align: center">Future Yes</td><td style="text-align: center">Future Yes</td></tr>
</tbody>
</table>
</div>
<h2 id="checking-rapl-is-available-on-your-cpu"><a class="header" href="#checking-rapl-is-available-on-your-cpu">Checking RAPL is available on your CPU</a></h2>
<p>Sensors including ‚ÄúRAPL‚Äù in their name rely on <a href="#explanation-on-rapl--running-average-power-limit-domains-what-we-think-we-know-so-far">RAPL</a>.</p>
<p>The <code>pts</code> and <code>pln</code> feature flags (‚ÄúIntel Package Thermal Status‚Äù and ‚ÄúIntel Power Limit Notification‚Äù respectively) seem to indicate that RAPL is supported on a CPU. On GNU/Linux, you could be sure of their presence, if this command succeds and matches :</p>
<pre><code>egrep "(pts|pln)" /proc/cpuinfo
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h1>
<h3 id="i-get-a-permission-denied-error-when-i-run-scaphandre-no-matter-what-is-the-exporter"><a class="header" href="#i-get-a-permission-denied-error-when-i-run-scaphandre-no-matter-what-is-the-exporter">I get a <strong>permission denied</strong> error when I run scaphandre, no matter what is the exporter</a></h3>
<p>Since Linux kernel 5.10 (late 2020), the energy counters files that the <a href="#powercap_rapl-sensor">PowercapRAPL sensor</a> uses, are owned by root.</p>
<p>To ensure this is your issue and fix that quickly you can run the <a href="https://raw.githubusercontent.com/hubblo-org/scaphandre/main/init.sh">init.sh</a> script:</p>
<pre><code>bash init.sh
</code></pre>
<p>Then run scaphandre. If it does not work, the issue is somewhere else.</p>
<h3 id="i-get-a-no-such-device-error-the-intel_rapl-of-intel_rapl_common-kernel-modules-are-present"><a class="header" href="#i-get-a-no-such-device-error-the-intel_rapl-of-intel_rapl_common-kernel-modules-are-present">I get a <strong>no such device</strong> error, the intel_rapl of intel_rapl_common kernel modules are present</a></h3>
<p>It can mean that your cpu doesn‚Äôt support RAPL. Please refer to the <a href="#compatibility">compatibility</a> section to be sure.</p>
<h3 id="i-cant-mount-the-required-kernel-modules-getting-a-couldnt-find-xxx-modules-error"><a class="header" href="#i-cant-mount-the-required-kernel-modules-getting-a-couldnt-find-xxx-modules-error">I can‚Äôt mount the required kernel modules, getting a <code>Could'nt find XXX modules</code> error</a></h3>
<p>If you are in a situation comparable to <a href="https://github.com/hubblo-org/scaphandre/issues/59">this one</a>, you may need to install additional packages.</p>
<p>On ubuntu 20.01 and 20.10, try to install <code>linux-modules-extra-$(uname -r)</code> with apt. Then you should be able to <code>modprobe intel_rapl_common</code>.</p>
<h3 id="on-an-amd-cpu-machine-i-get-the-following-stracktrace"><a class="header" href="#on-an-amd-cpu-machine-i-get-the-following-stracktrace">On an AMD cpu machine, I get the following stracktrace</a></h3>
<pre><code>scaphandre::sensors::powercap_rapl: Couldn't find intel_rapl modules.
thread 'main' panicked at 'Trick: if you are running on a vm, do not forget to use --vm parameter invoking scaphandre at the command line', src/sensors/mod.rs:238:18
stack backtrace:
   0: rust_begin_unwind
             at /build/rust/src/rustc-1.49.0-src/library/std/src/panicking.rs:495:5
   1: core::panicking::panic_fmt
             at /build/rust/src/rustc-1.49.0-src/library/core/src/panicking.rs:92:14
   2: core::option::expect_failed
             at /build/rust/src/rustc-1.49.0-src/library/core/src/option.rs:1260:5
   3: core::option::Option&lt;T&gt;::expect
             at /build/rust/src/rustc-1.49.0-src/library/core/src/option.rs:349:21
   4: scaphandre::sensors::Topology::add_cpu_cores
             at ./src/sensors/mod.rs:234:26
   5: &lt;scaphandre::sensors::powercap_rapl::PowercapRAPLSensor as scaphandre::sensors::Sensor&gt;::generate_topology
             at ./src/sensors/powercap_rapl.rs:106:9
   6: &lt;scaphandre::sensors::powercap_rapl::PowercapRAPLSensor as scaphandre::sensors::Sensor&gt;::get_topology
             at ./src/sensors/powercap_rapl.rs:112:24
   7: scaphandre::exporters::stdout::StdoutExporter::new
             at ./src/exporters/stdout.rs:51:30
   8: scaphandre::run
             at ./src/lib.rs:60:28
   9: scaphandre::main
             at ./src/main.rs:91:5
  10: core::ops::function::FnOnce::call_once
             at /build/rust/src/rustc-1.49.0-src/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>We verified that scaphandre (and especially the powercap_rapl sensor) works on AMD Zen processors with a Linux kernel <strong>5.11 or later</strong>. Before that kernel version, it won‚Äôt probably work as the <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=AMD-Zen-PowerCap-RAPL-5.11">drivers</a> needed to feed powercap with rapl data are not present.</p>
<h3 id="trying-to-build-the-project-i-get-this-error"><a class="header" href="#trying-to-build-the-project-i-get-this-error">Trying to build the project I get this error</a></h3>
<pre><code>error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)

error: aborting due to previous error

error: could not compile `log`
</code></pre>
<p>You need compiling tooling. On Ubuntu/Debian, run:</p>
<pre><code> sudo apt install build-essential
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributing-guide"><a class="header" href="#contributing-guide">Contributing guide</a></h1>
<p>If you are reading this, you may be  to contribute. Just for that, a big thank you ! üëè</p>
<p>Feel free to propose pull requests, or open new <a href="https://github.com/hubblo-org/scaphandre/discussions">discussions</a> or <a href="https://github.com/hubblo-org/scaphandre/issues">issues</a> at will. Scaphandre is a collaborative project and all opinions and propositions shall be heard and studied. The contributions will be received with kindness, gratitude and with an open mind. Remember that we are all <a href="https://en.wikipedia.org/wiki/Standing_on_the_shoulders_of_giants">dwarfs standing on the shoulders of giants</a>. We all have to learn from others and to give back, with due mutual respect.</p>
<h3 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of conduct</a></h3>
<p>This project adheres to the Rust Code of Conduct, which <a href="https://www.rust-lang.org/conduct.html">can be found here</a>.</p>
<h3 id="ways-to-contribute"><a class="header" href="#ways-to-contribute">Ways to contribute</a></h3>
<p>Contributions may take multiple forms:</p>
<ul>
<li>üíª <strong>code</strong>, of course, but not only (there is a lot more !)</li>
<li>üìñ <strong>documentation</strong> : <a href="#edit-and-build-the-documentation">here</a> is a guide to edit and build the documentation</li>
<li>üé§ Any help on <strong>communication</strong>: writing blog posts, speaking about scaphandre in conferences, speaking and writing about the responsibility of tech to be sustainable as well !</li>
<li>üß¨ <strong>structuring the project</strong> and the <strong>community</strong> is also a very important topic. Feel free to propose help, or start <a href="https://github.com/hubblo-org/scaphandre/discussions">discussions</a> about that.</li>
</ul>
<p>This project intends to unite a lot of people to have a lot of positive impact. Any action going helping us to get there will be very much appreciated ! üéâ</p>
<h3 id="contact"><a class="header" href="#contact">Contact</a></h3>
<p>Discussions and questions about the project are welcome on <a href="https://gitter.im/hubblo-org/scaphandre?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge">gitter</a> or by <a href="mailto://bpetit@hubblo.org?Subject=About%20Scaphandre">email</a>.</p>
<h3 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution guidelines</a></h3>
<p>This project intends to use <a href="https://conventionalcommits.org/">conventional commit messages</a> and the <a href="https://nvie.com/posts/a-successful-git-branching-model/">gitflow</a> workflow.</p>
<p>Please open your pull requests on the <strong>dev</strong> branch :)</p>
<p>Scaphandre is a not only a tool, but a framework. Modules dedicated to collect energy consumption data from the host are called <a href="#sensors"><strong>Sensors</strong></a>.
Modules that are dedicated to send this data to a given channel or remote system are called <a href="#exporters"><strong>Exporters</strong></a>. New Sensors and Exporters are going to be created and all contributions are welcome. For more on the internal structure please jump <a href="#internal-structure">here</a>.</p>
<h3 id="edit-and-build-the-documentation"><a class="header" href="#edit-and-build-the-documentation">Edit and build the documentation</a></h3>
<p>Documentation source files are in <code>docs_src</code>, edit the content there and propose pull-requests on the scaphandre repository as if it was a code pull-request.</p>
<p>Here is how to build and publish the documentation after a change. First download <a href="https://github.com/rust-lang/mdBook">mdbook</a>, the static site generator we use for the <a href="https://hubblo-org.github.io/scaphandre-documentation">documentation website</a>:</p>
<pre><code>cargo install mdbook
</code></pre>
<p>Then fork the <a href="https://github.com/hubblo-org/scaphandre-documentation">scaphandre-documentation</a> repository and clone the resulting repository locally.</p>
<p>Place the resulting documentation folder next to scaphandre‚Äôs folder. Then run the build:</p>
<pre><code>cd scaphandre &amp;&amp; mdbook build
</code></pre>
<p>You should then have the result in <code>scaphandre-documentation/docs</code>. Commit, push and propose a PR to publish the changes.</p>
<p>You can also serve the current content locally to see your changes before commit:</p>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="additional-references-for-documentation"><a class="header" href="#additional-references-for-documentation">Additional references for documentation</a></h1>
<ul>
<li><a href="http://www.linuxhowtos.org/System/procstat.htm">/proc/stat explained</a></li>
<li><a href="https://www.idnt.net/en-US/kb/941772">Gathering CPU utilization from /proc/stat</a></li>
<li><a href="https://www.mjmwired.net/kernel/Documentation/filesystems/proc.txt#1212">proc filesystem documentation</a></li>
<li><a href="https://www.opsdash.com/blog/cpu-usage-linux.html">CPU usage on Linux</a></li>
<li><a href="https://community.intel.com/t5/Software-Tuning-Performance/Using-RAPL-to-read-PP0-and-DRAM-energy-on-haswell/td-p/1076202">Using RAPL to read PP0 and DRAM energy on Haswell</a></li>
<li><a href="http://web.eece.maine.edu/~vweaver/projects/rapl/">RAPL reference</a></li>
<li><a href="https://ma.ttias.be/how-to-measure-linux-performance-avoiding-most-typical-mistakes-cpu/">How to measure linux performance avoiding most typical mistakes: CPU</a></li>
<li><a href="https://www.embedded.com/how-to-calculate-cpu-utilization/">How to calculate cpu utilization</a></li>
</ul>
<h1 id="powercaprapl-source-code-in-the-kernel"><a class="header" href="#powercaprapl-source-code-in-the-kernel">Powercap/RAPL source code in the kernel</a></h1>
<ul>
<li>arch/x86/events/intel/rapl.c</li>
<li>drivers/powercap</li>
</ul>
<h1 id="topics-to-investigate"><a class="header" href="#topics-to-investigate">Topics to investigate</a></h1>
<ul>
<li><a href="https://facebookmicrosites.github.io/psi/docs/overview">PSI</a></li>
<li><a href="https://unixism.net/2019/08/linux-pressure-stall-information-psi-by-example/">Linux PSI by example</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/accounting/psi.html">PSI - Pressure Stall Information</a></li>
<li><a href="https://ma.ttias.be/how-to-measure-linux-performance-avoiding-most-typical-mistakes-memory/">How to measure linux performance avoiding most typical mistakes: memory</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>

        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
